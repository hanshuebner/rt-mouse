# RT-Mouse Emulator

**IMPORTANT: This is an LLM-generated implementation.** This project was created by analyzing AIX and BSD header files using a Large Language Model (LLM). The code is not an original work of any human author, but rather a reconstruction of the IBM 6150 RT PC mouse protocol based on historical documentation and header files. The implementations (both JavaScript and Swift) were generated by an LLM to validate the protocol analysis.

## Overview

The RT-Mouse emulator is an AI-generated implementation that allows modern computers to interface with systems expecting the IBM 6150 RT PC mouse protocol. This project contains two proof-of-concept implementations that were automatically generated by an LLM to validate the protocol analysis and ensure compatibility with the original IBM 6150 RT PC mouse:

- **JavaScript Version**: An LLM-generated browser-based POC that uses a browser window to track mouse movements and button states
- **Swift Version**: An LLM-generated native macOS POC that uses system APIs for mouse tracking and event handling

Both implementations were automatically created by an LLM to verify the protocol specification and demonstrate that the analyzed protocol is correct and functional. They provide the same protocol interface, making them interchangeable from the host system's perspective, though they are not intended for production use in their current form.

## Wiring the Serial Port

The IBM RT PC mouse port uses a 6-pin connector with the following pinout (as viewed looking into the male socket on the back of the RT system):

```
+--------------+            1 = ground.
|    1  3  5   |            2 = Transmit to device.
|              |            3 = +12 Volts
 -   2  4  6  -             4 = -12 Volts
  |          |              5 =  +5 Volts
  +----------+              6 = Receive from device.
```

To connect the RT mouse port to a standard female 9-pin serial (DB9) connector (the "device" in the diagram), use the following mapping:

| RT Mouse Pin | Signal                | DB9 Pin | DB9 Signal Name   |
|--------------|-----------------------|---------|-------------------|
| 1            | Ground                | 5       | GND               |
| 2            | Transmit to device    | 2       | RXD (to PC)       |
| 3            | +12V                  | (N/C)   | (not connected)   |
| 4            | -12V                  | (N/C)   | (not connected)   |
| 5            | +5V                   | (N/C)   | (not connected)   |
| 6            | Receive from device   | 3       | TXD (from PC)     |


## Mouse Protocol

The RT-Mouse protocol operates over a serial connection (9600 baud, 8 data bits, odd parity, 1 stop bit) and uses a command/response system.

### Initialization Sequence

1. Host sends `RESET` command (0x01)
2. Mouse responds with `RESET_ACK` (0xFF 0x08 0x00 0x00)
3. Host sends `READ_CONFIG` command (0x06)
4. Mouse responds with `CONFIGURED` (0x20 0x00 0x00 0x00)
5. Host can then enable the mouse with `ENABLE` command (0x08)

### Commands

| Command | Value | Description |
|---------|-------|-------------|
| RESET | 0x01 | Resets the mouse and returns RESET_ACK |
| READ_CONFIG | 0x06 | Returns CONFIGURED response |
| ENABLE | 0x08 | Enables mouse reporting |
| DISABLE | 0x09 | Disables mouse reporting |
| READ_DATA | 0x0B | Returns a data report |
| WRAP_ON | 0x0E | Enables wrap mode |
| WRAP_OFF | 0x0F | Disables wrap mode |
| SET_SCALE_EXP | 0x78 | Sets exponential scaling |
| SET_SCALE_LIN | 0x6C | Sets linear scaling |
| READ_STATUS | 0x73 | Returns status report |
| SET_RATE | 0x8A | Sets report rate (followed by rate byte) |
| SET_MODE | 0x8D | Sets mode (followed by mode byte) |
| SET_RESOLUTION | 0x89 | Sets resolution (followed by resolution byte) |

### Data Reports

Mouse movement and button state changes are reported in 4-byte packets:

```
Byte 0: 0x0B (Data report magic number)
Byte 1: Status byte
        Bit 7: Right button (1 = pressed)
        Bit 6: Middle button (1 = pressed)
        Bit 5: Left button (1 = pressed)
        Bit 4: Always 0
        Bit 3: Reset bit (normally 0)
        Bit 2: X sign bit (1 = negative)
        Bit 1: Y sign bit (1 = negative)
        Bit 0: Always 0
Byte 2: X movement (two's complement)
Byte 3: Y movement (two's complement)
```

### Status Reports

Status reports (in response to READ_STATUS) are 4-byte packets:

```
Byte 0: 0x61 (Status report magic number)
Byte 1: Status byte
        Bit 7: Always 0
        Bit 6: Always 0
        Bit 5: Disabled (1 = disabled)
        Bit 4: Scaling (1 = exponential)
        Bit 3: Mode (1 = remote)
        Bit 2: Always 1
        Bit 1: Always 0
        Bit 0: Always 0
Byte 2: Resolution (counts per inch)
Byte 3: Sample rate (reports per second)
```

## Protocol Notes

- The mouse operates in two modes: "stream" (default) and "remote"
- Movement can be scaled linearly or exponentially
- Resolution and sample rate are configurable
- The protocol supports wrap mode for continuous movement
- All movement values are signed 8-bit integers (-128 to 127)
- Button states are reported in every movement packet
- The protocol includes error detection through parity

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

**Important Note on Copyright and Licensing:** This software was generated by an LLM based on analysis of historical IBM and BSD code. While we provide it under the MIT License, there are complex and unresolved legal questions regarding copyright of LLM-generated code, especially when it's derived from copyrighted source material. The original protocol and implementations were created by IBM and the BSD development teams, and their copyrights and licenses may technically still apply. However, given that this is a reconstruction of a historical protocol for compatibility purposes, and considering the practical difficulties in determining the exact copyright status of LLM-generated code, we suggest proceeding under the MIT License while acknowledging these potential complications.

## Acknowledgments

The original protocol design and documentation is the work of IBM and the AIX/BSD development teams. This project merely reconstructs their work through LLM analysis.
